#!/usr/bin/env bash

# è®¾ç½®ï¼šé‡åˆ°é”™è¯¯æˆ–ä½¿ç”¨æœªå®šä¹‰å˜é‡æ—¶é€€å‡º
set -eu

# ==========================================================
# WSS éš§é“åŸºç¡€è®¾æ–½ä¸€é”®éƒ¨ç½²è„šæœ¬ (çº¯æ ¸å¿ƒåŠŸèƒ½ç‰ˆ)
# =============================
# æç¤ºç«¯å£é…ç½®
# =============================
echo "----------------------------------"
echo "==== WSS åŸºç¡€è®¾æ–½ç«¯å£é…ç½® ===="

read -p "è¯·è¾“å…¥ WSS HTTP ç›‘å¬ç«¯å£ (é»˜è®¤80): " WSS_HTTP_PORT
WSS_HTTP_PORT=${WSS_HTTP_PORT:-80}

read -p "è¯·è¾“å…¥ WSS TLS ç›‘å¬ç«¯å£ (é»˜è®¤443): " WSS_TLS_PORT
WSS_TLS_PORT=${WSS_TLS_PORT:-443}

read -p "è¯·è¾“å…¥ Stunnel4 ç«¯å£ (é»˜è®¤444): " STUNNEL_PORT
STUNNEL_PORT=${STUNNEL_PORT:-444}

read -p "è¯·è¾“å…¥ UDPGW ç«¯å£ (é»˜è®¤7300): " UDPGW_PORT
UDPGW_PORT=${UDPGW_PORT:-7300}

# === å†…éƒ¨è½¬å‘ç«¯å£æç¤º ===
read -p "è¯·è¾“å…¥ WSS/Stunnel å†…éƒ¨ SSH è½¬å‘ç«¯å£ (é»˜è®¤48303, æ­¤ä¸º WSS/Stunnel è¿æ¥åˆ° SSH çš„ç«¯å£): " INTERNAL_FORWARD_PORT
INTERNAL_FORWARD_PORT=${INTERNAL_FORWARD_PORT:-48303}
# ==============================

echo "----------------------------------"
echo "==== ç³»ç»Ÿæ›´æ–°ä¸ä¾èµ–å®‰è£… ===="
# ä»…ä¿ç•™æ ¸å¿ƒç»„ä»¶ä¾èµ–ï¼špython3, wget, curl, git, net-tools, cmake, build-essential, openssl, stunnel4, iproute2, iptables
# ç§»é™¤ flask, jinja2, uvloop ç­‰é¢æ¿ä¾èµ–
apt update -y
apt install -y python3 python3-pip wget curl git net-tools cmake build-essential openssl stunnel4 iproute2 iptables
echo "æ ¸å¿ƒä¾èµ–å®‰è£…å®Œæˆ"
echo "----------------------------------"


# =============================
# WSS æ ¸å¿ƒä»£ç†è„šæœ¬
# =============================
echo "==== å®‰è£… WSS æ ¸å¿ƒä»£ç†è„šæœ¬ (/usr/local/bin/wss) ===="
# ä½¿ç”¨ <<'EOF' é¿å… Bash é¢„è§£æ $INTERNAL_FORWARD_PORT
tee /usr/local/bin/wss > /dev/null <<EOF
#!/usr/bin/python3
# -*- coding: utf-8 -*-

import asyncio, ssl, sys
import os # å¯¼å…¥ os æ£€æŸ¥ uvloop
try:
    import uvloop # å¯¼å…¥ uvloop, ç”¨äºé«˜æ€§èƒ½ event loop (å¦‚æœå·²å®‰è£…)
    UVLOOP_AVAILABLE = True
except ImportError:
    UVLOOP_AVAILABLE = False
    print("Warning: uvloop not found. Using default asyncio loop.")


LISTEN_ADDR = '0.0.0.0'

try:
Â  Â  HTTP_PORT = int(sys.argv[1])
except (IndexError, ValueError):
Â  Â  HTTP_PORT = 80
try:
Â  Â  TLS_PORT = int(sys.argv[2])
except (IndexError, ValueError):
Â  Â  TLS_PORT = 443

# ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„å†…éƒ¨è½¬å‘ç«¯å£
DEFAULT_TARGET = ('127.0.0.1', $INTERNAL_FORWARD_PORT)
BUFFER_SIZE = 65536
TIMEOUT = 3600
CERT_FILE = '/etc/stunnel/certs/stunnel.pem'
KEY_FILE = '/etc/stunnel/certs/stunnel.key'

FIRST_RESPONSE = b'HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 2\r\n\r\nOK\r\n\r\n'
SWITCH_RESPONSE = b'HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n'
FORBIDDEN_RESPONSE = b'HTTP/1.1 403 Forbidden\r\nContent-Length: 0\r\n\r\n'

async def handle_client(reader: asyncio.StreamReader, writer: asyncio.StreamWriter, tls=False):
Â  Â  peer = writer.get_extra_info('peername')
Â  Â  print(f"Connection from {peer} {'(TLS)' if tls else ''}")
Â  Â  forwarding_started = False
Â  Â  full_request = b''

Â  Â  try:
Â  Â  Â  Â  # --- 1. æ¡æ‰‹å¾ªç¯ ---
Â  Â  Â  Â  while not forwarding_started:
Â  Â  Â  Â  Â  Â  # å¢åŠ è¶…æ—¶å¤„ç†ï¼Œé¿å…é•¿è¿æ¥æŒ‚èµ·
Â  Â  Â  Â  Â  Â  data = await asyncio.wait_for(reader.read(BUFFER_SIZE), timeout=TIMEOUT)
Â  Â  Â  Â  Â  Â  if not data:
Â  Â  Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  full_request += data
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  header_end_index = full_request.find(b'\r\n\r\n')
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if header_end_index == -1:
Â  Â  Â  Â  Â  Â  Â  Â  # å¤´éƒ¨ä¸å®Œæ•´ï¼Œå‘é€ 200 OK å¹¶ç­‰å¾…ä¸‹ä¸€æ®µ (Payload å…¼å®¹æ€§)
Â  Â  Â  Â  Â  Â  Â  Â  writer.write(FIRST_RESPONSE)
Â  Â  Â  Â  Â  Â  Â  Â  await writer.drain()
Â  Â  Â  Â  Â  Â  Â  Â  full_request = b''
Â  Â  Â  Â  Â  Â  Â  Â  continue

Â  Â  Â  Â  Â  Â  # 2. å¤´éƒ¨è§£æ
Â  Â  Â  Â  Â  Â  headers_raw = full_request[:header_end_index]
Â  Â  Â  Â  Â  Â  data_to_forward = full_request[header_end_index + 4:]
Â  Â  Â  Â  Â  Â  headers = headers_raw.decode(errors='ignore')

Â  Â  Â  Â  Â  Â  # æ£€æŸ¥æ˜¯å¦æ˜¯ WebSocket å‡çº§è¯·æ±‚æˆ–è‡ªå®šä¹‰ Payload æ ‡è®°
Â  Â  Â  Â  Â  Â  is_websocket_request = 'Upgrade: websocket' in headers or 'Connection: Upgrade' in headers or 'GET-RAY' in headers
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  # 3. è½¬å‘è§¦å‘
Â  Â  Â  Â  Â  Â  if is_websocket_request:
Â  Â  Â  Â  Â  Â  Â  Â  # å‘é€ 101 åˆ‡æ¢åè®®å“åº”
Â  Â  Â  Â  Â  Â  Â  Â  writer.write(SWITCH_RESPONSE)
Â  Â  Â  Â  Â  Â  Â  Â  await writer.drain()
Â  Â  Â  Â  Â  Â  Â  Â  forwarding_started = True
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  # é WebSocket è¯·æ±‚ï¼Œå‘é€ 200 OK å¹¶ç»§ç»­ç­‰å¾…
Â  Â  Â  Â  Â  Â  Â  Â  writer.write(FIRST_RESPONSE)
Â  Â  Â  Â  Â  Â  Â  Â  await writer.drain()
Â  Â  Â  Â  Â  Â  Â  Â  full_request = b''
Â  Â  Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â Â 
Â  Â  Â  Â  # --- é€€å‡ºæ¡æ‰‹å¾ªç¯ ---

Â  Â  Â  Â  # 4. è¿æ¥ç›®æ ‡æœåŠ¡å™¨ (é»˜è®¤åˆ° Stunnel/SSH çš„è½¬å‘ç«¯å£)
Â  Â  Â  Â  target = DEFAULT_TARGET
Â  Â  Â  Â  target_reader, target_writer = await asyncio.open_connection(*target)

Â  Â  Â  Â  # 5. è½¬å‘åˆå§‹æ•°æ® (SSH æ¡æ‰‹åŒ…)
Â  Â  Â  Â  if data_to_forward:
Â  Â  Â  Â  Â  Â  target_writer.write(data_to_forward)
Â  Â  Â  Â  Â  Â  await target_writer.drain()
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  # 6. è½¬å‘åç»­æ•°æ®æµ
Â  Â  Â  Â  async def pipe(src_reader, dst_writer):
Â  Â  Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  Â  Â  while True:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buf = await src_reader.read(BUFFER_SIZE)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if not buf:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dst_writer.write(buf)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await dst_writer.drain()
Â  Â  Â  Â  Â  Â  except Exception:
Â  Â  Â  Â  Â  Â  Â  Â  pass
Â  Â  Â  Â  Â  Â  finally:
Â  Â  Â  Â  Â  Â  Â  Â  dst_writer.close()

Â  Â  Â  Â  await asyncio.gather(
Â  Â  Â  Â  Â  Â  pipe(reader, target_writer),
Â  Â  Â  Â  Â  Â  pipe(target_reader, writer)
Â  Â  Â  Â  )

Â  Â  except Exception as e:
Â  Â  Â  Â  print(f"Connection error {peer}: {e}")
Â  Â  finally:
Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  writer.close()
Â  Â  Â  Â  Â  Â  await writer.wait_closed()
Â  Â  Â  Â  except Exception:
Â  Â  Â  Â  Â  Â  pass
Â  Â  Â  Â  print(f"Closed {peer}")

async def main():
Â  Â  # TLS server setup
Â  Â  ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
Â  Â  try:
Â  Â  Â  Â  ssl_ctx.load_cert_chain(certfile=CERT_FILE, keyfile=KEY_FILE)
Â  Â  Â  Â  tls_server = await asyncio.start_server(
Â  Â  Â  Â  Â  Â  lambda r, w: handle_client(r, w, tls=True), LISTEN_ADDR, TLS_PORT, ssl=ssl_ctx)
Â  Â  Â  Â  print(f"Listening on {LISTEN_ADDR}:{TLS_PORT} (TLS)")
Â  Â  Â  Â  tls_task = tls_server.serve_forever()
Â  Â  except FileNotFoundError:
Â  Â  Â  Â  print(f"WARNING: TLS certificate not found at {CERT_FILE}. TLS server disabled.")
Â  Â  Â  Â  tls_task = asyncio.sleep(86400) # Keep task running but effectively disabled
Â  Â  Â  Â Â 
Â  Â  http_server = await asyncio.start_server(
Â  Â  Â  Â  lambda r, w: handle_client(r, w, tls=False), LISTEN_ADDR, HTTP_PORT)
Â  Â Â 
Â  Â  print(f"Listening on {LISTEN_ADDR}:{HTTP_PORT} (HTTP payload)")

Â  Â  async with http_server:
Â  Â  Â  Â  await asyncio.gather(
Â  Â  Â  Â  Â  Â  tls_task,
Â  Â  Â  Â  Â  Â  http_server.serve_forever())

if __name__ == '__main__':
Â  Â  try:
        if UVLOOP_AVAILABLE:
Â  Â  Â  Â      uvloop.install()Â 
Â  Â  Â  Â  asyncio.run(main())
Â  Â  except KeyboardInterrupt:
Â  Â  Â  Â  print("WSS Proxy Stopped.")
Â  Â  Â  Â Â 
EOF

chmod +x /usr/local/bin/wss

# åˆ›å»º WSS systemd æœåŠ¡
tee /etc/systemd/system/wss.service > /dev/null <<EOF
[Unit]
Description=WSS Python Proxy
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/wss $WSS_HTTP_PORT $WSS_TLS_PORT
Restart=on-failure
User=root

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable wss
systemctl start wss
echo "WSS å·²å¯åŠ¨ï¼ŒHTTPç«¯å£ $WSS_HTTP_PORT, TLSç«¯å£ $WSS_TLS_PORT"
echo "----------------------------------"


# =============================
# å®‰è£… Stunnel4 å¹¶ç”Ÿæˆè¯ä¹¦
# =============================
echo "==== å®‰è£… Stunnel4 ===="
mkdir -p /etc/stunnel/certs
openssl req -x509 -nodes -newkey rsa:2048 \
-keyout /etc/stunnel/certs/stunnel.key \
-out /etc/stunnel/certs/stunnel.crt \
-days 1095 \
-subj "/CN=example.com" > /dev/null 2>&1
sh -c 'cat /etc/stunnel/certs/stunnel.key /etc/stunnel/certs/stunnel.crt > /etc/stunnel/certs/stunnel.pem'
chmod 644 /etc/stunnel/certs/*.crt
chmod 644 /etc/stunnel/certs/*.pem

tee /etc/stunnel/ssh-tls.conf > /dev/null <<EOF
pid=/var/run/stunnel.pid
setuid=root
setgid=root
client = no
debug = 5
output = /var/log/stunnel4/stunnel.log
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1

[ssh-tls-gateway]
accept = 0.0.0.0:$STUNNEL_PORT
cert = /etc/stunnel/certs/stunnel.pem
key = /etc/stunnel/certs/stunnel.pem
connect = 127.0.0.1:$INTERNAL_FORWARD_PORT
EOF

systemctl enable stunnel4
systemctl start stunnel4 # å¯åŠ¨æœåŠ¡ä»¥ä¾¿åç»­æ£€æŸ¥
echo "Stunnel4 å®‰è£…å®Œæˆï¼Œç«¯å£ $STUNNEL_PORT"
echo "----------------------------------"


# =============================
# å®‰è£… UDPGW
# =============================
echo "==== å®‰è£… UDPGW ===="
if [ ! -d "/root/badvpn" ]; then
Â  Â  git clone https://github.com/ambrop72/badvpn.git /root/badvpn
fi
mkdir -p /root/badvpn/badvpn-build
cd /root/badvpn/badvpn-build
cmake .. -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 > /dev/null 2>&1
make -j$(nproc) > /dev/null 2>&1
cd - > /dev/null

tee /etc/systemd/system/udpgw.service > /dev/null <<EOF
[Unit]
Description=UDP Gateway (Badvpn)
After=network.target

[Service]
Type=simple
ExecStart=/root/badvpn/badvpn-build/udpgw/badvpn-udpgw --listen-addr 127.0.0.1:$UDPGW_PORT --max-clients 1024 --max-connections-for-client 10
Restart=on-failure
User=root

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable udpgw
systemctl start udpgw # å¯åŠ¨æœåŠ¡ä»¥ä¾¿åç»­æ£€æŸ¥
echo "UDPGW å·²å®‰è£…å¹¶å¯åŠ¨ï¼Œç«¯å£: $UDPGW_PORT"
echo "----------------------------------"

# =============================
# Traffic Control åŸºç¡€é…ç½® (ç®€åŒ–)
# =============================
# ä¿æŒåŸºç¡€ HTB ç»“æ„ï¼Œä¸åŒ…å«ä»»ä½•ç”¨æˆ·é™åˆ¶é€»è¾‘ï¼ˆè¯¥é€»è¾‘å·²éšé¢æ¿ä»£ç ç§»é™¤ï¼‰
echo "==== é…ç½® Traffic Control (tc) åŸºç¡€ç¯å¢ƒ ===="
IP_DEV=$(ip route | grep default | sed -n 's/.*dev \([^ ]*\).*/\1/p' | head -1)

if [ -z "$IP_DEV" ]; then
Â  Â  echo "è­¦å‘Š: æ— æ³•æ‰¾åˆ°ä¸»ç½‘ç»œæ¥å£ï¼Œtc åŸºç¡€é…ç½®è·³è¿‡ã€‚"
else
Â  Â  # é”€æ¯æ‰€æœ‰ç°æœ‰çš„ qdisc
Â  Â  tc qdisc del dev "$IP_DEV" root || true
Â  Â  # åˆ›å»º HTB æ ¹ qdisc
Â  Â  tc qdisc add dev "$IP_DEV" root handle 1: htb default 10
Â  Â  # é»˜è®¤ç±»åˆ« (æ— é™åˆ¶)
Â  Â  tc class add dev "$IP_DEV" parent 1: classid 1:10 htb rate 1000mbit ceil 1000mbit
Â  Â  echo "Traffic Control (tc) å·²åœ¨ $IP_DEV ä¸Šåˆå§‹åŒ– (æ— ç”¨æˆ·é™åˆ¶è§„åˆ™)ã€‚"
fi
echo "----------------------------------"


# =============================
# ç§»é™¤æ‰€æœ‰é¢æ¿ç›¸å…³ä»£ç å’Œé…ç½®
# =============================
# é¢æ¿ä»£ç  (wss_panel.py) å·²ç§»é™¤ï¼Œæ— éœ€åœ¨æ­¤å¤„æ“ä½œã€‚
# é¢æ¿ systemd æœåŠ¡ (wss_panel.service) å·²ç§»é™¤ï¼Œæ— éœ€åœ¨æ­¤å¤„æ“ä½œã€‚
echo "==== ç§»é™¤ Web ç®¡ç†é¢æ¿æ®‹ç•™é…ç½® ===="
rm -f /usr/local/bin/wss_panel.py || true
rm -f /etc/systemd/system/wss_panel.service || true
systemctl daemon-reload || true
echo "Web ç®¡ç†é¢æ¿é…ç½®å·²æ¸…ç†ã€‚"
echo "----------------------------------"


# =============================
# SSHD å®‰å…¨é…ç½® (ç»Ÿä¸€ç­–ç•¥)
# =============================
SSHD_CONFIG="/etc/ssh/sshd_config"
BACKUP_SUFFIX=".bak.wss$(date +%s)"
SSHD_SERVICE=$(systemctl list-units --full -all | grep -q "sshd.service" && echo "sshd" || echo "ssh")

echo "==== é…ç½® SSHD å®‰å…¨ç­–ç•¥ (å…è®¸æœ¬æœºå¯†ç è®¤è¯) ===="
# å¤‡ä»½ sshd_config
cp -a "$SSHD_CONFIG" "${SSHD_CONFIG}${BACKUP_SUFFIX}"
echo "SSHD é…ç½®å·²å¤‡ä»½åˆ° ${SSHD_CONFIG}${BACKUP_SUFFIX}"

# åˆ é™¤æ—§çš„ WSS é…ç½®æ®µ
sed -i '/# WSS_TUNNEL_BLOCK_START/,/# WSS_TUNNEL_BLOCK_END/d' "$SSHD_CONFIG"

# å†™å…¥æ–°çš„ WSS éš§é“ç­–ç•¥
cat >> "$SSHD_CONFIG" <<EOF

# WSS_TUNNEL_BLOCK_START -- managed by deploy_wss_only.sh
# ç»Ÿä¸€ç­–ç•¥: å…è®¸æ‰€æœ‰ç”¨æˆ·é€šè¿‡æœ¬æœº (127.0.0.1, ::1) ä½¿ç”¨å¯†ç è¿›è¡Œè®¤è¯ã€‚
Match Address 127.0.0.1,::1
Â  Â  # å…è®¸å¯†ç è®¤è¯ï¼Œç”¨äº WSS/Stunnel éš§é“è¿æ¥
Â  Â  PasswordAuthentication yes
Â  Â  # å…è®¸ TTY å’Œè½¬å‘
Â  Â  PermitTTY yes
Â  Â  AllowTcpForwarding yes
# WSS_TUNNEL_BLOCK_END -- managed by deploy_wss_only.sh

EOF

chmod 600 "$SSHD_CONFIG"

# é‡è½½ sshd
echo "é‡æ–°åŠ è½½å¹¶é‡å¯ ssh æœåŠ¡ ($SSHD_SERVICE)"
systemctl daemon-reload
systemctl restart "$SSHD_SERVICE"
echo "SSHD é…ç½®æ›´æ–°å®Œæˆã€‚"
echo "----------------------------------"


# =============================
# æœ€ç»ˆé‡å¯æ‰€æœ‰å…³é”®æœåŠ¡
# =============================
echo "==== æœ€ç»ˆé‡å¯æ‰€æœ‰å…³é”®æœåŠ¡ï¼Œç¡®ä¿é…ç½®ç”Ÿæ•ˆ ===="
# ç§»é™¤ wss_panel
systemctl restart wss stunnel4 udpgw
echo "æ‰€æœ‰æ ¸å¿ƒæœåŠ¡é‡å¯å®Œæˆï¼šWSS, Stunnel4, UDPGWã€‚"
echo "----------------------------------"


echo "=================================================="
echo "âœ… éƒ¨ç½²å®Œæˆï¼"

echo "=================================================="
echo ""
echo "ğŸ”¥ WSS & Stunnel åŸºç¡€è®¾æ–½å·²å¯åŠ¨ã€‚"
echo "--- ç«¯å£ä¿¡æ¯ ---"
echo "WSS (HTTP/WebSocket): $WSS_HTTP_PORT"
echo "WSS (TLS/WebSocket): $WSS_TLS_PORT"
echo "Stunnel (TLS éš§é“): $STUNNEL_PORT"
echo "UDPGW (å†…éƒ¨ UDP è½¬å‘): $UDPGW_PORT"
echo "å†…éƒ¨ SSH è½¬å‘ç«¯å£: $INTERNAL_FORWARD_PORT (WSS/Stunnel ä»£ç†è¿æ¥åˆ° SSH çš„ç«¯å£)"
echo ""
echo "--- æ•…éšœæ’æŸ¥ ---"
echo "WSS ä»£ç†çŠ¶æ€: sudo systemctl status wss"
echo "Stunnel çŠ¶æ€: sudo systemctl status stunnel4"
echo "UDPGW çŠ¶æ€: sudo systemctl status udpgw"
echo "=================================================="
